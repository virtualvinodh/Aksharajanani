import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { Character, CharacterSet, GlyphData } from '../types';
import CharacterGrid from './CharacterGrid';
import { useLocale } from '../contexts/LocaleContext';
import { useLayout } from '../contexts/LayoutContext';
import ProgressIndicator from './ProgressIndicator';
import { useGlyphData } from '../contexts/GlyphDataContext';
import { useProject } from '../contexts/ProjectContext';
import { useSettings } from '../contexts/SettingsContext';
import { useKerning } from '../contexts/KerningContext';
import { usePositioning } from '../contexts/PositioningContext';
import { useBatchOperations } from '../hooks/useBatchOperations';
import { filterAndSortCharacters } from '../utils/searchUtils';
import { sanitizeIdentifier } from '../utils/stringUtils';
import { useRules } from '../contexts/RulesContext';
import DrawingWorkspaceHeader from './drawing/DrawingWorkspaceHeader';
import DrawingBatchToolbar from './drawing/DrawingBatchToolbar';
import DrawingWorkspaceDialogs from './drawing/DrawingWorkspaceDialogs';
import { isGlyphDrawn } from '../utils/glyphUtils';
import { calculateDefaultMarkOffset, getAccurateGlyphBBox } from '../services/glyphRenderService';
import { expandMembers } from '../services/groupExpansionService';
import { deepClone } from '../utils/cloneUtils';

interface DrawingWorkspaceProps {
    characterSets: CharacterSet[];
    onSelectCharacter: (character: Character, rect: DOMRect) => void;
    onAddGlyph: (targetSet?: string) => void;
    onAddBlock: () => void;
    drawingProgress: { completed: number; total: number };
}

const DrawingWorkspace: React.FC<DrawingWorkspaceProps> = ({ characterSets, onSelectCharacter, onAddGlyph, onAddBlock, drawingProgress }) => {
    const { t } = useLocale();
    const { 
        activeTab, setActiveTab, showNotification, 
        metricsSelection, setMetricsSelection, isMetricsSelectionMode, setIsMetricsSelectionMode, 
        filterMode, setComparisonCharacters, setCurrentView,
        searchQuery
    } = useLayout();
    
    const { dispatch: characterDispatch, positioningGroupNames, allCharsByName, allCharsByUnicode, markAttachmentRules, positioningRules } = useProject();
    const { settings, metrics } = useSettings();
    const { glyphDataMap, version: glyphVersion, dispatch: glyphDataDispatch } = useGlyphData();
    const { kerningMap, dispatch: kerningDispatch } = useKerning();
    const { markPositioningMap, dispatch: positioningDispatch } = usePositioning();
    const { state: rulesState } = useRules();
    const rulesGroups = rulesState.fontRules?.groups || {};

    const [contextMenu, setContextMenu] = useState({ x: 0, y: 0, index: -1, isOpen: false });
    const contextMenuRef = useRef<HTMLDivElement>(null);

    const [modalState, setModalState] = useState<{ type: 'create' | 'rename', index?: number, isOpen: boolean }>({ type: 'create', isOpen: false });
    const [modalInputValue, setModalInputValue] = useState('');
    const [showNamingHint, setShowNamingHint] = useState(false);

    const { handleBulkTransform, handleSaveMetrics, handleBulkDelete } = useBatchOperations();
    const [isTransformOpen, setIsTransformOpen] = useState(false);
    const [isPropertiesOpen, setIsPropertiesOpen] = useState(false);
    const [isDeleteOpen, setIsDeleteOpen] = useState(false);

    const showHidden = settings?.showHiddenGlyphs ?? false;
    const isSearching = searchQuery.trim().length > 0;
    const isFiltered = filterMode !== 'none' || isSearching;

    const visibleCharacterSets = useMemo(() => {
        if (isFiltered) return [];
        return characterSets
            .map(set => ({
                ...set,
                characters: set.characters.filter(char => (!char.hidden || showHidden) && char.unicode !== 8205 && char.unicode !== 8204)
            }))
            .filter(set => set.nameKey !== 'dynamicLigatures');
    }, [characterSets, showHidden, isFiltered]);

    const filteredFlatList = useMemo(() => {
        if (!isFiltered) return [];
        let candidates = characterSets.flatMap(set => set.characters).filter(char => {
            if (char.unicode === 8205 || char.unicode === 8204) return false;
            
            // Auto-Generated Logic
            if (filterMode === 'autoGenerated') {
                if (char.position) {
                     const [base, mark] = char.position;
                     const baseC = allCharsByName.get(base);
                     const markC = allCharsByName.get(mark);
                     if (baseC?.unicode !== undefined && markC?.unicode !== undefined) {
                         // Check if source components are drawn
                         const baseDrawn = isGlyphDrawn(glyphDataMap.get(baseC.unicode));
                         const markDrawn = isGlyphDrawn(glyphDataMap.get(markC.unicode));

                         if (baseDrawn && markDrawn) {
                             const key = `${baseC.unicode}-${markC.unicode}`;
                             return !markPositioningMap.has(key);
                         }
                     }
                 }
                 if (char.kern) {
                     const [left, right] = char.kern;
                     const leftC = allCharsByName.get(left);
                     const rightC = allCharsByName.get(right);
                     if (leftC?.unicode !== undefined && rightC?.unicode !== undefined) {
                         // Check if source components are drawn
                         const leftDrawn = isGlyphDrawn(glyphDataMap.get(leftC.unicode));
                         const rightDrawn = isGlyphDrawn(glyphDataMap.get(rightC.unicode));

                         if (leftDrawn && rightDrawn) {
                             const key = `${leftC.unicode}-${rightC.unicode}`;
                             return !kerningMap.has(key);
                         }
                     }
                 }
                 return false;
            }

            const drawn = glyphDataMap.has(char.unicode!);
            const matchesStatus = filterMode === 'all' || filterMode === 'none' || (filterMode === 'completed' && drawn) || (filterMode === 'incomplete' && !drawn);
            if (!matchesStatus) return false;
            return (!char.hidden || showHidden);
        });
        return isSearching ? filterAndSortCharacters(candidates, searchQuery) : candidates.sort((a, b) => (a.unicode || 0) - (b.unicode || 0));
    }, [characterSets, glyphDataMap, filterMode, showHidden, isFiltered, searchQuery, isSearching, markPositioningMap, kerningMap, allCharsByName]);

    // Check if the current selection consists ONLY of virtual glyphs (Positioned or Kerned)
    const isSelectionVirtual = useMemo(() => {
        if (metricsSelection.size === 0) return false;
        for (const unicode of metricsSelection) {
            const char = allCharsByUnicode.get(unicode);
            if (!char) return false;
            // Virtual glyphs must have either 'position' or 'kern' defined
            if (!char.position && !char.kern) return false;
        }
        return true;
    }, [metricsSelection, allCharsByUnicode]);

    const handleAcceptAll = useCallback(() => {
        if (filterMode !== 'autoGenerated' || filteredFlatList.length === 0 || !metrics || !settings) return;
    
        const newMarkPositioningMap = new Map(markPositioningMap);
        const newKerningMap = new Map(kerningMap);
        const glyphUpdates: [number, GlyphData][] = [];
        let count = 0;
    
        filteredFlatList.forEach(char => {
            // Positioning Logic
            if (char.position) {
                const [baseName, markName] = char.position;
                const baseChar = allCharsByName.get(baseName);
                const markChar = allCharsByName.get(markName);
    
                if (baseChar && markChar && baseChar.unicode !== undefined && markChar.unicode !== undefined) {
                    const key = `${baseChar.unicode}-${markChar.unicode}`;
                    
                    const baseGlyph = glyphDataMap.get(baseChar.unicode);
                    const markGlyph = glyphDataMap.get(markChar.unicode);

                    if (isGlyphDrawn(baseGlyph) && isGlyphDrawn(markGlyph)) {
                        const baseBbox = getAccurateGlyphBBox(baseGlyph!.paths, settings.strokeThickness);
                        const markBbox = getAccurateGlyphBBox(markGlyph!.paths, settings.strokeThickness);

                        let constraint: 'horizontal' | 'vertical' | 'none' = 'none';
                        const rule = positioningRules?.find(r => 
                            expandMembers(r.base, rulesGroups, characterSets).includes(baseChar.name) && 
                            expandMembers(r.mark || [], rulesGroups, characterSets).includes(markChar.name)
                        );
                        if (rule?.movement) constraint = rule.movement;

                        const offset = calculateDefaultMarkOffset(
                            baseChar, markChar, baseBbox, markBbox, 
                            markAttachmentRules, 
                            metrics, characterSets, false, rulesGroups, constraint
                        );

                        newMarkPositioningMap.set(key, offset);

                        if (rule?.gsub && char.unicode !== undefined) {
                            const transformedMarkPaths = deepClone(markGlyph!.paths).map((p: any) => ({
                                ...p,
                                points: p.points.map((pt: any) => ({ x: pt.x + offset.x, y: pt.y + offset.y })),
                                segmentGroups: p.segmentGroups ? p.segmentGroups.map((group: any) => group.map((seg: any) => ({...seg, point: { x: seg.point.x + offset.x, y: seg.point.y + offset.y } }))) : undefined
                            }));
                            
                            const combinedPaths = [...baseGlyph!.paths, ...transformedMarkPaths];
                            glyphUpdates.push([char.unicode, { paths: combinedPaths }]);
                        }
                        count++;
                    }
                }
            }
            
            // Kerning Logic
            if (char.kern) {
                 const [leftName, rightName] = char.kern;
                 const leftChar = allCharsByName.get(leftName);
                 const rightChar = allCharsByName.get(rightName);
                 
                 if (leftChar && rightChar && leftChar.unicode !== undefined && rightChar.unicode !== undefined) {
                     const key = `${leftChar.unicode}-${rightChar.unicode}`;
                     
                    const leftGlyph = glyphDataMap.get(leftChar.unicode);
                    const rightGlyph = glyphDataMap.get(rightChar.unicode);
                    
                    if (isGlyphDrawn(leftGlyph) && isGlyphDrawn(rightGlyph)) {
                        newKerningMap.set(key, 0);
                        count++;
                    }
                 }
            }
        });
    
        if (count > 0) {
            positioningDispatch({ type: 'SET_MAP', payload: newMarkPositioningMap });
            kerningDispatch({ type: 'SET_MAP', payload: newKerningMap });
            if (glyphUpdates.length > 0) {
                glyphDataDispatch({ type: 'BATCH_UPDATE_GLYPHS', payload: glyphUpdates });
            }
            showNotification(t('acceptedAutoGenerated', { count }), 'success');
        }
    }, [filteredFlatList, filterMode, markPositioningMap, kerningMap, glyphDataMap, allCharsByName, settings, metrics, markAttachmentRules, positioningRules, rulesGroups, characterSets, positioningDispatch, kerningDispatch, glyphDataDispatch, showNotification, t]);

    const handleSelectionAccept = useCallback(() => {
        if (metricsSelection.size === 0 || !metrics || !settings) return;
    
        const newMarkPositioningMap = new Map(markPositioningMap);
        const newKerningMap = new Map(kerningMap);
        const glyphUpdates: [number, GlyphData][] = [];
        let count = 0;
    
        metricsSelection.forEach(unicode => {
            const char = allCharsByUnicode.get(unicode);
            if (!char) return;

            // Positioning Logic
            if (char.position) {
                const [baseName, markName] = char.position;
                const baseChar = allCharsByName.get(baseName);
                const markChar = allCharsByName.get(markName);
    
                if (baseChar && markChar && baseChar.unicode !== undefined && markChar.unicode !== undefined) {
                    const key = `${baseChar.unicode}-${markChar.unicode}`;
                    
                    // Proceed even if it's already there (update/confirm)
                    const baseGlyph = glyphDataMap.get(baseChar.unicode);
                    const markGlyph = glyphDataMap.get(markChar.unicode);

                    // Ensure components are drawn
                    if (isGlyphDrawn(baseGlyph) && isGlyphDrawn(markGlyph)) {
                        const baseBbox = getAccurateGlyphBBox(baseGlyph!.paths, settings.strokeThickness);
                        const markBbox = getAccurateGlyphBBox(markGlyph!.paths, settings.strokeThickness);

                        // Determine constraint
                        let constraint: 'horizontal' | 'vertical' | 'none' = 'none';
                        const rule = positioningRules?.find(r => 
                            expandMembers(r.base, rulesGroups, characterSets).includes(baseChar.name) && 
                            expandMembers(r.mark || [], rulesGroups, characterSets).includes(markChar.name)
                        );
                        if (rule?.movement) constraint = rule.movement;

                        const offset = calculateDefaultMarkOffset(
                            baseChar, markChar, baseBbox, markBbox, 
                            markAttachmentRules, 
                            metrics, characterSets, false, rulesGroups, constraint
                        );

                        newMarkPositioningMap.set(key, offset);

                        // Handle GSUB (Ligature generation)
                        if (rule?.gsub && char.unicode !== undefined) {
                            const transformedMarkPaths = deepClone(markGlyph!.paths).map((p: any) => ({
                                ...p,
                                points: p.points.map((pt: any) => ({ x: pt.x + offset.x, y: pt.y + offset.y })),
                                segmentGroups: p.segmentGroups ? p.segmentGroups.map((group: any) => group.map((seg: any) => ({...seg, point: { x: seg.point.x + offset.x, y: seg.point.y + offset.y } }))) : undefined
                            }));
                            
                            const combinedPaths = [...baseGlyph!.paths, ...transformedMarkPaths];
                            glyphUpdates.push([char.unicode, { paths: combinedPaths }]);
                        }
                        count++;
                    }
                }
            }
            
            // Kerning Logic
            if (char.kern) {
                 const [leftName, rightName] = char.kern;
                 const leftChar = allCharsByName.get(leftName);
                 const rightChar = allCharsByName.get(rightName);
                 
                 if (leftChar && rightChar && leftChar.unicode !== undefined && rightChar.unicode !== undefined) {
                     const key = `${leftChar.unicode}-${rightChar.unicode}`;
                     
                    const leftGlyph = glyphDataMap.get(leftChar.unicode);
                    const rightGlyph = glyphDataMap.get(rightChar.unicode);
                    
                    if (isGlyphDrawn(leftGlyph) && isGlyphDrawn(rightGlyph)) {
                        // Set default 0 for accepted pairs
                        newKerningMap.set(key, 0);
                        count++;
                    }
                 }
            }
        });
    
        if (count > 0) {
            positioningDispatch({ type: 'SET_MAP', payload: newMarkPositioningMap });
            kerningDispatch({ type: 'SET_MAP', payload: newKerningMap });
            if (glyphUpdates.length > 0) {
                glyphDataDispatch({ type: 'BATCH_UPDATE_GLYPHS', payload: glyphUpdates });
            }
            showNotification(t('acceptedAutoGenerated', { count }), 'success');
        }
    }, [metricsSelection, markPositioningMap, kerningMap, glyphDataMap, allCharsByUnicode, allCharsByName, settings, metrics, markAttachmentRules, positioningRules, rulesGroups, characterSets, positioningDispatch, kerningDispatch, glyphDataDispatch, showNotification, t]);

    const currentGridCharacters = isFiltered ? filteredFlatList : (visibleCharacterSets[activeTab]?.characters || []);

    const handleTabContextMenu = (e: React.MouseEvent | React.TouchEvent, index: number) => {
        e.preventDefault();
        const clientX = 'touches' in e ? e.touches[0].clientX : (e as React.MouseEvent).clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent).clientY;
        setContextMenu({ x: Math.min(clientX, window.innerWidth - 160), y: Math.min(clientY, window.innerHeight - 100), index, isOpen: true });
    };

    const handleNameInput = (val: string) => {
        const sanitized = sanitizeIdentifier(val);
        setShowNamingHint(val.length > 0 && sanitized !== val.replace(/[\s-]+/g, '_'));
        setModalInputValue(sanitized);
    };

    const handleModalSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const name = modalInputValue.trim();
        if (!name) return;
        const lowerName = name.toLowerCase();
        
        if (modalState.type === 'create') {
             characterDispatch({ type: 'UPDATE_CHARACTER_SETS', payload: (prev) => prev ? [...prev, { nameKey: name, characters: [] }] : [{ nameKey: name, characters: [] }] });
             setTimeout(() => setActiveTab(visibleCharacterSets.length), 50);
        } else if (modalState.type === 'rename' && modalState.index !== undefined) {
            const targetSet = visibleCharacterSets[modalState.index];
            const realIndex = characterSets.findIndex(s => s.nameKey === targetSet.nameKey);
            characterDispatch({ type: 'UPDATE_CHARACTER_SETS', payload: (prev) => prev ? prev.map((set, i) => i === realIndex ? { ...set, nameKey: name } : set) : null });
        }
        setModalState(prev => ({ ...prev, isOpen: false }));
    };

    const handleBatchComplete = () => {
        setMetricsSelection(new Set());
        setIsMetricsSelectionMode(false);
        setIsPropertiesOpen(false);
        setIsTransformOpen(false);
        setIsDeleteOpen(false);
    };

    const getBannerText = () => {
        if (isSearching) return t('searchingFor', { query: searchQuery });
        switch(filterMode) {
            case 'completed': return t('filterCompleted');
            case 'incomplete': return t('filterIncomplete');
            case 'all': return t('filterAllFlat');
            case 'autoGenerated': return t('filterAutoGenerated');
            default: return '';
        }
    };

    return (
        <div className="flex flex-col h-full overflow-hidden relative">
            <DrawingWorkspaceHeader 
                visibleCharacterSets={visibleCharacterSets}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                glyphDataMap={glyphDataMap}
                glyphVersion={glyphVersion}
                showHidden={showHidden}
                isFiltered={isFiltered}
                bannerText={getBannerText()}
                resultCount={filteredFlatList.length}
                onAddGroup={() => { setModalInputValue(''); setShowNamingHint(false); setModalState({ type: 'create', isOpen: true }); }}
                onTabContextMenu={handleTabContextMenu}
                filterMode={filterMode}
                onAcceptAll={handleAcceptAll}
            />
            
            <div className="flex-shrink-0 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
                <ProgressIndicator completed={drawingProgress.completed} total={drawingProgress.total} progressTextKey="progressText" />
            </div>

            <div className="flex-grow overflow-hidden">
                {currentGridCharacters.length > 0 ? (
                    <CharacterGrid
                        key={isFiltered ? 'flat-list' : activeTab}
                        characters={currentGridCharacters}
                        onSelectCharacter={onSelectCharacter}
                        onAddGlyph={!isFiltered ? () => onAddGlyph(visibleCharacterSets[activeTab]?.nameKey) : () => {}}
                        onAddBlock={onAddBlock}
                    />
                ) : (
                    <div className="flex items-center justify-center h-full text-gray-500 italic">{isFiltered ? t('noMatchesFound') : t('noCharacters')}</div>
                )}
            </div>

            {isMetricsSelectionMode && (
                <DrawingBatchToolbar 
                    selectionSize={metricsSelection.size}
                    onSelectVisible={() => { const v = new Set<number>(); currentGridCharacters.forEach(c => c.unicode && v.add(c.unicode)); setMetricsSelection(v); }}
                    onSelectAll={() => { const a = new Set<number>(); characterSets.flatMap(s => s.characters).forEach(c => c.unicode && a.add(c.unicode)); setMetricsSelection(a); }}
                    onSelectNone={() => setMetricsSelection(new Set())}
                    onTransform={() => setIsTransformOpen(true)}
                    onProperties={() => setIsPropertiesOpen(true)}
                    onCompare={() => { 
                        // Fix: Use characterSets instead of visibleCharacterSets to ensure selected items are found even when filtered.
                        setComparisonCharacters(characterSets.flatMap(s => s.characters).filter(c => c.unicode !== undefined && metricsSelection.has(c.unicode))); 
                        setIsMetricsSelectionMode(false); 
                        setCurrentView('comparison'); 
                    }}
                    onDelete={() => setIsDeleteOpen(true)}
                    onClose={() => { setIsMetricsSelectionMode(false); setMetricsSelection(new Set()); }}
                    showAccept={isSelectionVirtual}
                    onAccept={handleSelectionAccept}
                />
            )}

            <DrawingWorkspaceDialogs 
                modalState={modalState} setModalState={setModalState}
                modalInputValue={modalInputValue} setModalInputValue={handleNameInput}
                showNamingHint={showNamingHint} handleModalSubmit={handleModalSubmit}
                isTransformOpen={isTransformOpen} setIsTransformOpen={setIsTransformOpen}
                onBulkTransform={(sx, sy, r, fh, fv) => handleBulkTransform(metricsSelection, sx, sy, r, fh, fv, handleBatchComplete)}
                isPropertiesOpen={isPropertiesOpen} setIsPropertiesOpen={setIsPropertiesOpen}
                onBulkProperties={(l, r) => handleSaveMetrics(metricsSelection, l, r, handleBatchComplete)}
                isDeleteOpen={isDeleteOpen} setIsDeleteOpen={setIsDeleteOpen}
                onBulkDelete={() => handleBulkDelete(metricsSelection, handleBatchComplete)}
                selectionSize={metricsSelection.size}
            />

            {contextMenu.isOpen && (
                <div ref={contextMenuRef} className="fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 shadow-xl rounded-lg z-[100] py-2 w-48 text-sm animate-pop-in" style={{ top: contextMenu.y, left: contextMenu.x }}>
                    <button onClick={() => { const name = visibleCharacterSets[contextMenu.index].nameKey; setModalInputValue(t(name) === name ? name : t(name)); setModalState({ type: 'rename', index: contextMenu.index, isOpen: true }); setContextMenu({ ...contextMenu, isOpen: false }); }} className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">Edit Name</button>
                    <button onClick={() => { if (visibleCharacterSets.length <= 1) { showNotification(t('cannotDeleteLastGroup'), 'error'); } else { const s = visibleCharacterSets[contextMenu.index]; if(window.confirm(t('confirmDeleteGroup', { name: t(s.nameKey) }))) characterDispatch({ type: 'UPDATE_CHARACTER_SETS', payload: (p) => p ? p.filter(x => x.nameKey !== s.nameKey) : null }); } setContextMenu({ ...contextMenu, isOpen: false }); }} className="w-full text-left px-4 py-2 hover:bg-red-50 dark:hover:bg-red-900/20 text-red-600 flex items-center gap-3">Delete Group</button>
                </div>
            )}
        </div>
    );
};

export default React.memo(DrawingWorkspace);