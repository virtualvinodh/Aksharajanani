
import { Character, KerningMap, MarkPositioningMap, PositioningRules, GlyphData, FontMetrics, Path, CharacterSet } from '../types';
import { getAccurateGlyphBBox, BoundingBox } from './glyphRenderService';
import { DRAWING_CANVAS_SIZE } from '../constants';
import { isGlyphDrawn as isGlyphDrawnUtil, getGlyphExportNameByUnicode } from '../utils/glyphUtils';
import { expandMembers } from './groupExpansionService';
import { deepClone } from '../utils/cloneUtils';

// --- Layer 2 Safeguard: Sanitize FEA Identifiers ---
// Ensures class names follow the Adobe FEA spec: Alphanumeric, underscores, periods, hyphens. No spaces.
const sanitizeIdentifier = (name: string) => name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_.-]/g, '');

// Use ASCII-safe uniXXXX names, which fontService will also use.
const getGlyphName = (char: Character | undefined): string | null => {
    if (!char || char.unicode === undefined) return null;
    return getGlyphExportNameByUnicode(char.unicode);
};

interface ContextualRuleValue {
    replace: string[];
    left?: string[];
    right?: string[];
}

export interface AutoGeneratedRule {
    input: string[];
    output: string;
}

/**
 * Calculates dynamic GSUB rules based on glyph metadata (position/composite properties).
 * Used by both the compiler and the UI for preview.
 */
export const getAutoGeneratedRules = (
    allCharsByUnicode: Map<number, Character>,
    glyphDataMap: Map<number, GlyphData>,
    featureTag: string
): AutoGeneratedRule[] => {
    const rules: AutoGeneratedRule[] = [];
    const nameToCharMap = new Map<string, Character>();
    allCharsByUnicode.forEach(char => nameToCharMap.set(char.name, char));

    const isNameDrawn = (name: string): boolean => {
        const char = nameToCharMap.get(name);
        if (!char || char.unicode === undefined) return false;
        if (char.unicode === 8205 || char.unicode === 8204) return true;
        return isGlyphDrawnUtil(glyphDataMap.get(char.unicode));
    };

    allCharsByUnicode.forEach(char => {
        // Only process characters that explicitly belong to this feature
        if (char.gsub !== featureTag) return;

        // Priority 1: Explicit 'liga' property (Overrides all else)
        if (char.liga && char.liga.length > 0) {
            // Verify all components in the liga definition exist and are drawn
            if (char.liga.every(comp => isNameDrawn(comp))) {
                rules.push({ input: char.liga, output: char.name });
                return; // Stop checking other properties for this character
            }
        }

        // Priority 2: Position-based (Virtual Syllables)
        // Must have position, MUST NOT have GPOS (which implies positioning, not substitution)
        if (char.position && !char.gpos) {
            const [baseName, markName] = char.position;
            if (isNameDrawn(baseName) && isNameDrawn(markName)) {
                rules.push({ input: [baseName, markName], output: char.name });
                return; // Stop checking
            }
        }

        // Priority 3: Visual Construction (Composite OR Link)
        // Fallback to visual components if no explicit logical definition exists
        const components = char.composite || char.link;

        if (components && components.length > 0) {
             if (components.every(comp => isNameDrawn(comp))) {
                 rules.push({ input: components, output: char.name });
             }
        }
    });

    return rules;
};

export const generateFea = (
    fontRules: any,
    kerningMap: KerningMap,
    markPositioningMap: MarkPositioningMap,
    allCharsByUnicode: Map<number, Character>,
    fontName: string,
    positioningRules: PositioningRules[] | null,
    glyphDataMap: Map<number, GlyphData>,
    metrics: FontMetrics,
    glyphBBoxes: Map<number, BoundingBox | null>,
    characterSets: CharacterSet[]
): string => {
    const scriptTag = Object.keys(fontRules).find(key => key !== 'groups' && key !== 'lookups');
    if (!scriptTag) {
        return `## Features for ${fontName}\n## Generated by Aksharajanani\n## ERROR: No script tag found in rules.\n\n`;
    }
    
    let feaContent = `languagesystem ${scriptTag} dflt;\n\n## Features for ${fontName}\n## Generated by Aksharajanani\n\n`;

    const allGsubFeatures: string[] = [];
    const allGposFeatures: string[] = [];

    const nameToCharMap = new Map<string, Character>();
    allCharsByUnicode.forEach(char => nameToCharMap.set(char.name, char));
    
    const nameToGlyphName = (name: string): string | null => {
        const char = nameToCharMap.get(name);
        return char ? getGlyphName(char) : null;
    };
    
    // Helper function to check if a glyph has been drawn
    const isGlyphDrawn = (char: Character | undefined): boolean => {
        if (!char || char.unicode === undefined) return false;
        // ZWJ and ZWNJ are special zero-width characters that should always be considered 'drawn' for rule generation.
        if (char.unicode === 8205 || char.unicode === 8204) {
            return true;
        }
        return isGlyphDrawnUtil(glyphDataMap.get(char.unicode));
    };

    const isNameDrawn = (name: string): boolean => {
        return isGlyphDrawn(nameToCharMap.get(name));
    };
    
    const groups = fontRules.groups || {};
    const lookups = fontRules.lookups;

    // Helper to check if a group contains at least one drawn glyph.
    const isGroupNonEmpty = (groupName: string): boolean => {
        if (!groups || !groups[groupName]) {
            return false; // Group doesn't exist.
        }
        const memberNames = groups[groupName] as string[];
        // Check if AT LEAST ONE member of the group is drawn.
        return memberNames.some(isNameDrawn);
    };

    // --- UNIVERSAL HELPERS for validation and name conversion ---
    const isItemDrawnOrNonEmptyGroup = (name: string): boolean => {
        if (name.startsWith('$')) {
            return isGroupNonEmpty(name.substring(1));
        }
        // Handle both conventions just in case, though '$' is user-facing
        if (name.startsWith('@')) {
             return isGroupNonEmpty(name.substring(1));
        }
        return isNameDrawn(name);
    };

    const toFeaName = (name: string): string | null => {
        if (name.startsWith('$')) {
            return `@${sanitizeIdentifier(name.substring(1))}`;
        }
        if (name.startsWith('@')) {
            return `@${sanitizeIdentifier(name.substring(1))}`;
        }
        return nameToGlyphName(name);
    };


    // --- Group Definitions from rules.json ---
    if (groups) {
        feaContent += '## Custom Glyph Groups\n\n';
        for (const groupName in groups) {
            if (Object.prototype.hasOwnProperty.call(groups, groupName)) {
                const memberNames = groups[groupName] as string[];
                const drawnMembers = memberNames
                    .map(name => nameToCharMap.get(name))
                    .filter(char => char && isGlyphDrawn(char))
                    .map(char => getGlyphName(char!))
                    .filter((name): name is string => name !== null);

                // FIX: Always generate the group definition, even if empty, to prevent compilation errors.
                // Apply Layer 2 Sanitization here
                feaContent += `@${sanitizeIdentifier(groupName)} = [${drawnMembers.join(' ')}];\n`;
            }
        }
        feaContent += '\n';
    }

    // --- Automatic Character Set Groups ---
    if (characterSets && characterSets.length > 0) {
        feaContent += '## Automatic Character Set Groups\n\n';
        characterSets.forEach(set => {
            const drawnMembers = set.characters
                .filter(char => isGlyphDrawn(char))
                .map(char => getGlyphName(char))
                .filter((name): name is string => name !== null);

            // Generate FEA class definition using the nameKey (e.g. @vowels)
            // Apply Layer 2 Sanitization here
            feaContent += `@${sanitizeIdentifier(set.nameKey)} = [${drawnMembers.join(' ')}];\n`;
        });
        feaContent += '\n';
    }


    // --- GDEF Table Generation ---
    const baseGlyphs: string[] = [];
    const ligatureGlyphs: string[] = [];
    const markGlyphs: string[] = [];

    allCharsByUnicode.forEach(char => {
        if (isGlyphDrawn(char)) {
            const glyphName = getGlyphName(char);
            if (glyphName) {
                switch (char.glyphClass) {
                    case 'ligature':
                        ligatureGlyphs.push(glyphName);
                        break;
                    case 'mark':
                        markGlyphs.push(glyphName);
                        break;
                    case 'base':
                    default:
                        if (char.unicode !== 32) {
                            baseGlyphs.push(glyphName);
                        }
                        break;
                }
            }
        }
    });

    let gdefContent = '## GDEF Table\n\n';
    const hasGlyphClasses = baseGlyphs.length > 0 || ligatureGlyphs.length > 0 || markGlyphs.length > 0;

    if (hasGlyphClasses) {
        if (baseGlyphs.length > 0) {
            gdefContent += `@baseGlyphs = [${baseGlyphs.join(' ')}];\n`;
        }
        if (ligatureGlyphs.length > 0) {
            gdefContent += `@ligatureGlyphs = [${ligatureGlyphs.join(' ')}];\n`;
        }
        if (markGlyphs.length > 0) {
            gdefContent += `@markGlyphs = [${markGlyphs.join(' ')}];\n`;
        }
        gdefContent += '\n';

        gdefContent += 'table GDEF {\n';
        gdefContent += '  GlyphClassDef\n';
        gdefContent += `    ${baseGlyphs.length > 0 ? '@baseGlyphs' : '[]'}, # Class 1: Base Glyphs\n`;
        gdefContent += `    ${ligatureGlyphs.length > 0 ? '@ligatureGlyphs' : '[]'}, # Class 2: Ligature Glyphs\n`;
        gdefContent += `    ${markGlyphs.length > 0 ? '@markGlyphs' : '[]'}, # Class 3: Mark Glyphs\n`;
        gdefContent += '    []; # Class 4: Component Glyphs\n';
        gdefContent += '} GDEF;\n\n';
    }
    
    feaContent += gdefContent;
    // --- End GDEF Table Generation ---

    // --- GSUB Features ---
    const scriptData = fontRules[scriptTag] || {}; // Direct access, use empty object if undefined

    let allLookupDefinitions = '';
    const generatedLookupNames = new Set<string>();

    const ruleGenerators = {
        single: (ruleBlock: any) => {
            let content = '';
            for (const outputName in ruleBlock) {
                const inputNames = ruleBlock[outputName];
                if (Array.isArray(inputNames) && inputNames.length > 0) {
                    const inputName = inputNames[0];
        
                    // Group-to-group substitution
                    if (outputName.startsWith('$') && inputName.startsWith('$')) {
                        const outputGroupName = outputName.substring(1);
                        const inputGroupName = inputName.substring(1);
                        const outputGroupMembers = groups?.[outputGroupName];
                        const inputGroupMembers = groups?.[inputGroupName];
        
                        if (outputGroupMembers && inputGroupMembers) {
                            if (outputGroupMembers.length !== inputGroupMembers.length) {
                                console.warn(`Mismatched group lengths in single substitution: @${inputGroupName} (${inputGroupMembers.length}) -> @${outputGroupName} (${outputGroupMembers.length}). Skipping rule.`);
                                continue;
                            }
                            if (isItemDrawnOrNonEmptyGroup(inputName) && isItemDrawnOrNonEmptyGroup(outputName)) {
                                const inputFeaName = toFeaName(inputName);
                                const outputFeaName = toFeaName(outputName);
                                if (inputFeaName && outputFeaName) {
                                    content += `  sub ${inputFeaName} by ${outputFeaName};\n`;
                                }
                            }
                        }
                    } 
                    // Group-to-glyph substitution
                    else if (inputName.startsWith('$')) {
                         if (isItemDrawnOrNonEmptyGroup(inputName) && isNameDrawn(outputName)) {
                             const inputFeaName = toFeaName(inputName);
                             const outputGlyph = nameToGlyphName(outputName);
                             if (inputFeaName && outputGlyph) {
                                content += `  sub ${inputFeaName} by ${outputGlyph};\n`;
                             }
                         }
                    }
                    // Glyph-to-group is not standard OTF syntax for `single`, it would be a 'multiple' sub.
        
                    // Standard single substitution
                    else {
                        const inputGlyph = nameToGlyphName(inputName);
                        const outputGlyph = nameToGlyphName(outputName);
                        if (inputGlyph && outputGlyph && isNameDrawn(inputName) && isNameDrawn(outputName)) {
                            content += `  sub ${inputGlyph} by ${outputGlyph};\n`;
                        }
                    }
                }
            }
            return content;
        },
        liga: (ruleBlock: any) => {
            let content = '';
            for (const ligName in ruleBlock) {
                const componentNames = ruleBlock[ligName];
                if (Array.isArray(componentNames)) {
                    if (isNameDrawn(ligName) && componentNames.every(isItemDrawnOrNonEmptyGroup)) {
                        const componentGlyphs = componentNames.map(toFeaName).filter(Boolean);
                        const ligGlyph = nameToGlyphName(ligName);
                        if (ligGlyph && componentGlyphs.length > 0) {
                            content += `  sub ${componentGlyphs.join(' ')} by ${ligGlyph};\n`;
                        }
                    }
                }
            }
            return content;
        },
        multi: (ruleBlock: any) => {
            let content = '';
            for (const outputString in ruleBlock) {
                const inputNames = ruleBlock[outputString];
                if (!Array.isArray(inputNames) || inputNames.length === 0) continue;
                
                const inputName = inputNames[0];
                if (!isItemDrawnOrNonEmptyGroup(inputName)) continue;
                const inputFeaName = toFeaName(inputName);
                if (!inputFeaName) continue;
        
                const outputComponentNames = outputString.split(',').map(s => s.trim()).filter(Boolean);
                if (outputComponentNames.length === 0) continue;
        
                // Direct translation, no expansion
                const outputFeaNames = outputComponentNames.map(toFeaName).filter(Boolean);
        
                // Check if all components were resolved successfully
                if (outputFeaNames.length !== outputComponentNames.length) {
                    console.warn(`Could not resolve all output components for multi sub rule: '${outputString}'. Skipping rule.`);
                    continue;
                }
        
                if (outputFeaNames.length > 0) {
                    content += `  sub ${inputFeaName} by ${outputFeaNames.join(' ')};\n`;
                }
            }
            return content;
        },
        context: (ruleBlock: any) => {
            let content = '';
            for (const replacementName in ruleBlock) {
                const rule = ruleBlock[replacementName] as ContextualRuleValue;
                if (rule && Array.isArray(rule.replace) && rule.replace.length > 0) {
                    const targetNames = rule.replace;
                    const leftNames = rule.left || [];
                    const rightNames = rule.right || [];
                    
                    if (isNameDrawn(replacementName) && targetNames.every(isItemDrawnOrNonEmptyGroup) && leftNames.every(isItemDrawnOrNonEmptyGroup) && rightNames.every(isItemDrawnOrNonEmptyGroup)) {
                        const targetGlyphs = targetNames.map(toFeaName).filter(Boolean);
                        const replacementGlyph = nameToGlyphName(replacementName);
                        if (targetGlyphs.length > 0 && replacementGlyph) {
                            const leftGlyphs = leftNames.map(toFeaName).filter(Boolean);
                            const rightGlyphs = rightNames.map(toFeaName).filter(Boolean);
                            
                            const leftPart = leftGlyphs.join(' ');
                            const targetPart = targetGlyphs.map(g => `${g}'`).join(' ');
                            const rightPart = rightGlyphs.join(' ');
                            
                            const fullSequence = [leftPart, targetPart, rightPart].filter(Boolean).join(' ');
                            content += `  sub ${fullSequence} by ${replacementGlyph};\n`;
                        }
                    }
                }
            }
            return content;
        }
    };

    if (lookups) {
        for (const lookupName in lookups) {
            if (Object.prototype.hasOwnProperty.call(lookups, lookupName)) {
                const lookupBlock = lookups[lookupName];
                let namedLookupContent = '';

                if (lookupBlock.lookupflags) {
                    for (const flagName in lookupBlock.lookupflags) {
                        if (Object.prototype.hasOwnProperty.call(lookupBlock.lookupflags, flagName)) {
                            const flagValue = lookupBlock.lookupflags[flagName];
                            namedLookupContent += `  lookupflag ${flagName} ${flagValue};\n`;
                        }
                    }
                }

                for (const ruleType in lookupBlock) {
                    if (Object.prototype.hasOwnProperty.call(lookupBlock, ruleType) && ruleGenerators[ruleType as keyof typeof ruleGenerators]) {
                        namedLookupContent += ruleGenerators[ruleType as keyof typeof ruleGenerators](lookupBlock[ruleType]);
                    }
                }
                if (namedLookupContent) {
                    // Apply Layer 2 Sanitization here for lookup name
                    const safeLookupName = sanitizeIdentifier(lookupName);
                    allLookupDefinitions += `lookup ${safeLookupName} {\n${namedLookupContent}} ${safeLookupName};\n\n`;
                    generatedLookupNames.add(lookupName);
                }
            }
        }
    }

    // 1. Collect all features while preserving implicit/explicit distinctions
    const explicitFeatures = Object.keys(scriptData);
    const impliedFeatures = new Set<string>();
    allCharsByUnicode.forEach(char => {
        if (char.gsub) {
            impliedFeatures.add(char.gsub);
        }
    });

    // 2. Ordered List: Explicit features first (order from rules.json), then new implied ones appended
    const allFeatures = [...explicitFeatures];
    impliedFeatures.forEach(tag => {
        if (!explicitFeatures.includes(tag)) {
            allFeatures.push(tag);
        }
    });

    for (const featureTag of allFeatures) {
        if (featureTag === 'dist') continue; // GPOS handled later
    
        // Get feature definition. If it's a "Ghost" feature (implied but not in rules), use default.
        const rawFeatureData = scriptData[featureTag];
        const featureData = rawFeatureData || { children: [{ type: 'auto_generated' }] };
        
        // Ensure children exists (fallback for legacy/malformed data)
        const children = featureData.children || [];
        
        // Detect and handle legacy structure (rules directly on feature object)
        const effectiveChildren = [...children];
        if (effectiveChildren.length === 0) {
             let hasInline = false;
             for (const ruleType in featureData) {
                if (ruleGenerators[ruleType as keyof typeof ruleGenerators]) {
                    hasInline = true;
                    break;
                }
             }
             if (hasInline) effectiveChildren.push({ type: 'inline' });
             effectiveChildren.push({ type: 'auto_generated' });
        }
        
        let featureLookups: string[] = [];
        
        // Pre-calculate inline content if needed
        let inlineContentCache = '';
        const generateInlineContent = () => {
             if (inlineContentCache) return inlineContentCache;
             let content = '';
             for (const ruleType in featureData) {
                if (ruleGenerators[ruleType as keyof typeof ruleGenerators]) {
                    content += ruleGenerators[ruleType as keyof typeof ruleGenerators](featureData[ruleType]);
                }
            }
            inlineContentCache = content;
            return content;
        };

        for (const child of effectiveChildren) {
            if (child.type === 'lookup') {
                featureLookups.push(child.name);
            } else if (child.type === 'inline') {
                const inlineContent = generateInlineContent();
                if (inlineContent.trim() !== '') {
                    const anonLookupName = `${featureTag}_inline_rules`;
                    
                    let lookupBody = '';
                    if (featureData.lookupflags) {
                        for (const flagName in featureData.lookupflags) {
                             if (Object.prototype.hasOwnProperty.call(featureData.lookupflags, flagName)) {
                                lookupBody += `  lookupflag ${flagName} ${featureData.lookupflags[flagName]};\n`;
                            }
                        }
                    }
                    lookupBody += inlineContent;
                    
                    if (!allLookupDefinitions.includes(`lookup ${anonLookupName}`)) {
                        allLookupDefinitions += `lookup ${anonLookupName} {\n${lookupBody}} ${anonLookupName};\n\n`;
                        generatedLookupNames.add(anonLookupName);
                    }
                    featureLookups.push(anonLookupName);
                }
            } else if (child.type === 'auto_generated') {
                 const dynamicRules = getAutoGeneratedRules(allCharsByUnicode, glyphDataMap, featureTag);
                 if (dynamicRules.length > 0) {
                     let content = '';
                     
                     // Apply feature flags to auto-generated lookup too for consistency
                     if (featureData.lookupflags) {
                        for (const flagName in featureData.lookupflags) {
                             if (Object.prototype.hasOwnProperty.call(featureData.lookupflags, flagName)) {
                                content += `  lookupflag ${flagName} ${featureData.lookupflags[flagName]};\n`;
                            }
                        }
                    }

                     dynamicRules.forEach(r => {
                         const inputs = r.input.map(n => toFeaName(n)).filter(Boolean).join(' ');
                         const output = toFeaName(r.output);
                         if(inputs && output) content += `  sub ${inputs} by ${output};\n`;
                     });
                     
                     if (content) {
                        const lookupName = `${featureTag}_auto_generated`;
                        if (!allLookupDefinitions.includes(`lookup ${lookupName}`)) {
                             allLookupDefinitions += `lookup ${lookupName} {\n${content}} ${lookupName};\n\n`;
                             generatedLookupNames.add(lookupName);
                        }
                        featureLookups.push(lookupName);
                     }
                 }
            }
        }
            
        const validLookups = featureLookups.filter(name => generatedLookupNames.has(name));
    
        if (validLookups.length > 0) {
            let featureBlock = `feature ${featureTag} {\n`;
            validLookups.forEach(name => {
                featureBlock += `  lookup ${sanitizeIdentifier(name)};\n`;
            });
            featureBlock += `} ${featureTag};\n\n`;
            feaContent += featureBlock;
            if (!allGsubFeatures.includes(featureTag)) allGsubFeatures.push(featureTag);
        }
    }
    
    // Add all lookup definitions before the first feature that uses them.
    feaContent = feaContent.replace('## GDEF Table', `${allLookupDefinitions}## GDEF Table`);
    
    // --- GPOS Features ---
    const gposFeatures = new Map<string, string[]>();
    const FONT_HEIGHT = metrics.ascender - metrics.descender;
    const scale = FONT_HEIGHT / DRAWING_CANVAS_SIZE;

    const pairToGposTag = new Map<string, string>();

    // Priority 1: Populate from positioning.json rules.
    if (positioningRules) {
        positioningRules.forEach(rule => {
            if (rule.gpos) {
                const bases = expandMembers(rule.base, groups, characterSets);
                const marks = expandMembers(rule.mark || [], groups, characterSets);
                bases.forEach(baseName => {
                    marks.forEach(markName => {
                        pairToGposTag.set(`${baseName}-${markName}`, rule.gpos!);
                    });
                });
            }
        });
    }

    // Priority 2: Populate with fallbacks from characters.json.
    allCharsByUnicode.forEach(char => {
        if (char.position && char.gpos) {
            const [baseName, markName] = char.position;
            const pairKey = `${baseName}-${markName}`;
            if (!pairToGposTag.has(pairKey)) { // Only add if not already defined (priority)
                pairToGposTag.set(pairKey, char.gpos);
            }
        }
    });

    if (pairToGposTag.size > 0) {
        const markClasses = new Map<string, string>(); // mark glyph name -> class name
        
        markPositioningMap.forEach((offset, key) => {
            const [baseUnicode, markUnicode] = key.split('-').map(Number);
            const baseChar = allCharsByUnicode.get(baseUnicode);
            const markChar = allCharsByUnicode.get(markUnicode);

            if (!baseChar || !markChar || !isGlyphDrawn(baseChar) || !isGlyphDrawn(markChar)) return;
            
            const gposTag = pairToGposTag.get(`${baseChar.name}-${markChar.name}`);
            if (!gposTag) return; 

            const baseGlyphName = getGlyphName(baseChar);
            const markGlyphName = getGlyphName(markChar);
            if (!baseGlyphName || !markGlyphName) return;

            const baseBbox = glyphBBoxes.get(baseUnicode);
            const markBbox = glyphBBoxes.get(markUnicode);
            if (!baseBbox || !markBbox) return;

            let markClassName = markClasses.get(markGlyphName);
            if (!markClassName) {
                markClassName = `@mark_${markGlyphName}`;
                markClasses.set(markGlyphName, markClassName);
            }

            if (!gposFeatures.has(gposTag)) gposFeatures.set(gposTag, []);
            
            const LSB_f = baseChar.lsb ?? metrics.defaultLSB;
            
            const canvas_distance_x = (markBbox.x + offset.x) - baseBbox.x;
            const font_distance_x = canvas_distance_x * scale;
            const anchorX = Math.round(LSB_f + font_distance_x);

            const anchorY = Math.round(-offset.y * scale);
            
            if (baseChar.glyphClass === 'mark') {
                if (!markClasses.has(baseGlyphName)) {
                    markClasses.set(baseGlyphName, `@mark_${baseGlyphName}`);
                }
                gposFeatures.get(gposTag)!.push(`  pos mark ${baseGlyphName} <anchor ${anchorX} ${anchorY}> mark ${markClassName};\n`);
            } else {
                gposFeatures.get(gposTag)!.push(`  pos base ${baseGlyphName} <anchor ${anchorX} ${anchorY}> mark ${markClassName};\n`);
            }
        });

        if(markClasses.size > 0) {
            feaContent += '## Mark Classes\n';
            markClasses.forEach((className, glyphName) => {
                feaContent += `markClass ${glyphName} <anchor 0 0> ${className};\n`;
            });
            feaContent += '\n';
        }

        gposFeatures.forEach((rules, tag) => {
            feaContent += `feature ${tag} {\n${rules.join('')}} ${tag};\n\n`;
            if (!allGposFeatures.includes(tag)) allGposFeatures.push(tag);
        });
    }

    let distContent = '';
    kerningMap.forEach((value, key) => {
        const [leftUnicode, rightUnicode] = key.split('-').map(Number);
        const leftChar = allCharsByUnicode.get(leftUnicode);
        const rightChar = allCharsByUnicode.get(rightUnicode);

        if (leftChar && rightChar && isGlyphDrawn(leftChar) && isGlyphDrawn(rightChar) && value !== 0) {
            const leftGlyph = getGlyphName(leftChar);
            const rightGlyph = getGlyphName(rightChar);
            if (leftGlyph && rightGlyph) {
                distContent += `  pos ${leftGlyph} ${rightGlyph} ${value};\n`;
            }
        }
    });
    
    if (scriptData.dist) {
        if (scriptData.dist.simple) {
            for (const charOrGroupName in scriptData.dist.simple) {
                if (!isItemDrawnOrNonEmptyGroup(charOrGroupName)) continue;
                const feaName = toFeaName(charOrGroupName);
                if (!feaName) continue;
                const value = scriptData.dist.simple[charOrGroupName];
                distContent += `  pos ${feaName} <0 0 ${value} 0>;\n`;
            }
        }

        if (scriptData.dist.contextual && Array.isArray(scriptData.dist.contextual)) {
            scriptData.dist.contextual.forEach((rule: any) => {
                const charName = rule.target;
                if (!charName) return;
                
                if (typeof rule === 'object' && rule !== null && rule.space) {
                    const leftNames = rule.left || [];
                    const rightNames = rule.right || [];
                    
                    if (isItemDrawnOrNonEmptyGroup(charName) && leftNames.every(isItemDrawnOrNonEmptyGroup) && rightNames.every(isItemDrawnOrNonEmptyGroup)) {
                        const glyphName = toFeaName(charName);
                        if (!glyphName) return;

                        const leftGlyphs = leftNames.map(toFeaName).filter(Boolean);
                        const rightGlyphs = rightNames.map(toFeaName).filter(Boolean);
                        
                        const leftContext = leftGlyphs.length > 0 ? `${leftGlyphs.join(' ')} ` : '';
                        const rightContext = rightGlyphs.length > 0 ? ` ${rightGlyphs.join(' ')}` : '';
                        
                        distContent += `  pos ${leftContext}${glyphName}'${rightContext} <0 0 ${rule.space} 0>;\n`;
                    }
                }
            });
        }
    }
    
    if (distContent.trim() === '') {
        // Add a dummy rule to ensure the feature block is valid if no other rules are present
        distContent = '  # No kerning or distance rules defined.\n';
    }

    feaContent += `feature dist {\n${distContent}} dist;\n\n`;
    if (!allGposFeatures.includes('dist')) {
        allGposFeatures.push('dist');
    }

    return feaContent;
};

export const exportFeaFile = (
    fontRules: any,
    kerningMap: KerningMap,
    markPositioningMap: MarkPositioningMap,
    allCharsByUnicode: Map<number, Character>,
    fontName: string,
    positioningRules: PositioningRules[] | null,
    glyphDataMap: Map<number, GlyphData>,
    metrics: FontMetrics,
    strokeThickness: number = 15,
    characterSets: CharacterSet[]
) => {
    const glyphBBoxes = new Map<number, BoundingBox | null>();
    glyphDataMap.forEach((glyphData, unicode) => {
        glyphBBoxes.set(unicode, getAccurateGlyphBBox(glyphData.paths, strokeThickness));
    });

    const feaContent = generateFea(
        fontRules,
        kerningMap,
        markPositioningMap,
        allCharsByUnicode,
        fontName,
        positioningRules,
        glyphDataMap,
        metrics,
        glyphBBoxes,
        characterSets
    );

    const blob = new Blob([feaContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Apply Layer 2 Sanitization here for filename as a courtesy
    a.download = `${sanitizeIdentifier(fontName)}.fea`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

export const exportJsonRules = (rules: any, fontName: string) => {
    const jsonString = JSON.stringify(rules, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Apply Layer 2 Sanitization here for filename
    a.download = `${sanitizeIdentifier(fontName)}_rules.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};
