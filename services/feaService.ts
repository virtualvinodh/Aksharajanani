

import { Character, KerningMap, MarkPositioningMap, PositioningRules, GlyphData, FontMetrics, Path, CharacterSet } from '../types';
import { getAccurateGlyphBBox, BoundingBox } from './glyphRenderService';
import { DRAWING_CANVAS_SIZE } from '../constants';
import { isGlyphDrawn as isGlyphDrawnUtil, getGlyphExportNameByUnicode } from '../utils/glyphUtils';
import { expandMembers } from './groupExpansionService';
import { deepClone } from '../utils/cloneUtils';

// --- Layer 2 Safeguard: Sanitize FEA Identifiers ---
// Ensures class names follow the Adobe FEA spec: Alphanumeric, underscores, periods, hyphens. No spaces.
const sanitizeIdentifier = (name: string) => name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_.-]/g, '');

// Use ASCII-safe uniXXXX names, which fontService will also use.
const getGlyphName = (char: Character | undefined): string | null => {
    if (!char || char.unicode === undefined) return null;
    return getGlyphExportNameByUnicode(char.unicode);
};

interface ContextualRuleValue {
    replace: string[];
    left?: string[];
    right?: string[];
}

export const generateFea = (
    fontRules: any,
    kerningMap: KerningMap,
    markPositioningMap: MarkPositioningMap,
    allCharsByUnicode: Map<number, Character>,
    fontName: string,
    positioningRules: PositioningRules[] | null,
    glyphDataMap: Map<number, GlyphData>,
    metrics: FontMetrics,
    glyphBBoxes: Map<number, BoundingBox | null>,
    characterSets: CharacterSet[]
): string => {
    const scriptTag = Object.keys(fontRules).find(key => key !== 'groups' && key !== 'lookups');
    if (!scriptTag) {
        return `## Features for ${fontName}\n## Generated by Aksharajanani\n## ERROR: No script tag found in rules.\n\n`;
    }
    
    let feaContent = `languagesystem ${scriptTag} dflt;\n\n## Features for ${fontName}\n## Generated by Aksharajanani\n\n`;

    const allGsubFeatures: string[] = [];
    const allGposFeatures: string[] = [];

    const nameToCharMap = new Map<string, Character>();
    allCharsByUnicode.forEach(char => nameToCharMap.set(char.name, char));
    
    const nameToGlyphName = (name: string): string | null => {
        const char = nameToCharMap.get(name);
        return char ? getGlyphName(char) : null;
    };
    
    // Helper function to check if a glyph has been drawn
    const isGlyphDrawn = (char: Character | undefined): boolean => {
        if (!char || char.unicode === undefined) return false;
        // ZWJ and ZWNJ are special zero-width characters that should always be considered 'drawn' for rule generation.
        if (char.unicode === 8205 || char.unicode === 8204) {
            return true;
        }
        return isGlyphDrawnUtil(glyphDataMap.get(char.unicode));
    };

    const isNameDrawn = (name: string): boolean => {
        return isGlyphDrawn(nameToCharMap.get(name));
    };
    
    const groups = fontRules.groups || {};
    const lookups = fontRules.lookups;

    // Helper to check if a group contains at least one drawn glyph.
    const isGroupNonEmpty = (groupName: string): boolean => {
        if (!groups || !groups[groupName]) {
            return false; // Group doesn't exist.
        }
        const memberNames = groups[groupName] as string[];
        // Check if AT LEAST ONE member of the group is drawn.
        return memberNames.some(isNameDrawn);
    };

    // --- UNIVERSAL HELPERS for validation and name conversion ---
    const isItemDrawnOrNonEmptyGroup = (name: string): boolean => {
        if (name.startsWith('$')) {
            return isGroupNonEmpty(name.substring(1));
        }
        // Handle both conventions just in case, though '$' is user-facing
        if (name.startsWith('@')) {
             return isGroupNonEmpty(name.substring(1));
        }
        return isNameDrawn(name);
    };

    const toFeaName = (name: string): string | null => {
        if (name.startsWith('$')) {
            return `@${sanitizeIdentifier(name.substring(1))}`;
        }
        if (name.startsWith('@')) {
            return `@${sanitizeIdentifier(name.substring(1))}`;
        }
        return nameToGlyphName(name);
    };


    // --- Group Definitions from rules.json ---
    if (groups) {
        feaContent += '## Custom Glyph Groups\n\n';
        for (const groupName in groups) {
            if (Object.prototype.hasOwnProperty.call(groups, groupName)) {
                const memberNames = groups[groupName] as string[];
                const drawnMembers = memberNames
                    .map(name => nameToCharMap.get(name))
                    .filter(char => char && isGlyphDrawn(char))
                    .map(char => getGlyphName(char!))
                    .filter((name): name is string => name !== null);

                // FIX: Always generate the group definition, even if empty, to prevent compilation errors.
                // Apply Layer 2 Sanitization here
                feaContent += `@${sanitizeIdentifier(groupName)} = [${drawnMembers.join(' ')}];\n`;
            }
        }
        feaContent += '\n';
    }

    // --- Automatic Character Set Groups ---
    if (characterSets && characterSets.length > 0) {
        feaContent += '## Automatic Character Set Groups\n\n';
        characterSets.forEach(set => {
            const drawnMembers = set.characters
                .filter(char => isGlyphDrawn(char))
                .map(char => getGlyphName(char))
                .filter((name): name is string => name !== null);

            // Generate FEA class definition using the nameKey (e.g. @vowels)
            // Apply Layer 2 Sanitization here
            feaContent += `@${sanitizeIdentifier(set.nameKey)} = [${drawnMembers.join(' ')}];\n`;
        });
        feaContent += '\n';
    }


    // --- GDEF Table Generation ---
    const baseGlyphs: string[] = [];
    const ligatureGlyphs: string[] = [];
    const markGlyphs: string[] = [];

    allCharsByUnicode.forEach(char => {
        if (isGlyphDrawn(char)) {
            const glyphName = getGlyphName(char);
            if (glyphName) {
                switch (char.glyphClass) {
                    case 'ligature':
                        ligatureGlyphs.push(glyphName);
                        break;
                    case 'mark':
                        markGlyphs.push(glyphName);
                        break;
                    case 'base':
                    default:
                        if (char.unicode !== 32) {
                            baseGlyphs.push(glyphName);
                        }
                        break;
                }
            }
        }
    });

    let gdefContent = '## GDEF Table\n\n';
    const hasGlyphClasses = baseGlyphs.length > 0 || ligatureGlyphs.length > 0 || markGlyphs.length > 0;

    if (hasGlyphClasses) {
        if (baseGlyphs.length > 0) {
            gdefContent += `@baseGlyphs = [${baseGlyphs.join(' ')}];\n`;
        }
        if (ligatureGlyphs.length > 0) {
            gdefContent += `@ligatureGlyphs = [${ligatureGlyphs.join(' ')}];\n`;
        }
        if (markGlyphs.length > 0) {
            gdefContent += `@markGlyphs = [${markGlyphs.join(' ')}];\n`;
        }
        gdefContent += '\n';

        gdefContent += 'table GDEF {\n';
        gdefContent += '  GlyphClassDef\n';
        gdefContent += `    ${baseGlyphs.length > 0 ? '@baseGlyphs' : '[]'}, # Class 1: Base Glyphs\n`;
        gdefContent += `    ${ligatureGlyphs.length > 0 ? '@ligatureGlyphs' : '[]'}, # Class 2: Ligature Glyphs\n`;
        gdefContent += `    ${markGlyphs.length > 0 ? '@markGlyphs' : '[]'}, # Class 3: Mark Glyphs\n`;
        gdefContent += '    []; # Class 4: Component Glyphs\n';
        gdefContent += '} GDEF;\n\n';
    }
    
    feaContent += gdefContent;
    // --- End GDEF Table Generation ---

    // --- GSUB Features ---
    const scriptData = deepClone(fontRules[scriptTag]); // Make a mutable copy

    // Inject dynamic GSUB rules from characters.json (position-based)
    allCharsByUnicode.forEach(char => {
        // Condition: Is a composite, IS NOT GPOS, but IS GSUB
        if (char.position && !char.gpos && char.gsub) {
            const [baseName, markName] = char.position;
            // Don't generate rules for undrawn components.
            if (!isNameDrawn(baseName) || !isNameDrawn(markName)) return;
    
            const featureTag = char.gsub;
            // Ensure feature and rule type exist
            if (!scriptData[featureTag]) scriptData[featureTag] = {};
            if (!scriptData[featureTag].liga) scriptData[featureTag].liga = {};
    
            // Add the rule. The existing `liga` generator expects this format.
            scriptData[featureTag].liga[char.name] = [baseName, markName];
        }
    });
    
    // Inject dynamic GSUB rules for detached/composite glyphs
    allCharsByUnicode.forEach(char => {
        // Condition: Character IS a composite AND has a GSUB feature tag.
        // This is the pattern for a detached GPOS glyph that should now act as a GSUB ligature.
        if (char.composite && char.gsub) {
            // This rule type is for pairs that were "detached".
            // It's a safe assumption for any character originating from a 'position' pair.
            if (char.composite.length !== 2) return;
    
            const [baseName, markName] = char.composite;
            const featureTag = char.gsub;
            const ligatureName = char.name;
    
            // CRITICAL: Reuse existing validation to avoid invalid rules.
            if (!isNameDrawn(baseName) || !isNameDrawn(markName)) return;
    
            // --- Inject the rule into the temporary `scriptData` object ---
            // Ensure the data structure is initialized.
            if (!scriptData[featureTag]) scriptData[featureTag] = {};
            if (!scriptData[featureTag].liga) scriptData[featureTag].liga = {};
    
            // Add the rule.
            scriptData[featureTag].liga[ligatureName] = [baseName, markName];
        }
    });

    let allLookupDefinitions = '';
    const generatedLookupNames = new Set<string>();

    const ruleGenerators = {
        single: (ruleBlock: any) => {
            let content = '';
            for (const outputName in ruleBlock) {
                const inputNames = ruleBlock[outputName];
                if (Array.isArray(inputNames) && inputNames.length > 0) {
                    const inputName = inputNames[0];
        
                    // Group-to-group substitution
                    if (outputName.startsWith('$') && inputName.startsWith('$')) {
                        const outputGroupName = outputName.substring(1);
                        const inputGroupName = inputName.substring(1);
                        const outputGroupMembers = groups?.[outputGroupName];
                        const inputGroupMembers = groups?.[inputGroupName];
        
                        if (outputGroupMembers && inputGroupMembers) {
                            if (outputGroupMembers.length !== inputGroupMembers.length) {
                                console.warn(`Mismatched group lengths in single substitution: @${inputGroupName} (${inputGroupMembers.length}) -> @${outputGroupName} (${outputGroupMembers.length}). Skipping rule.`);
                                continue;
                            }
                            if (isItemDrawnOrNonEmptyGroup(inputName) && isItemDrawnOrNonEmptyGroup(outputName)) {
                                const inputFeaName = toFeaName(inputName);
                                const outputFeaName = toFeaName(outputName);
                                if (inputFeaName && outputFeaName) {
                                    content += `  sub ${inputFeaName} by ${outputFeaName};\n`;
                                }
                            }
                        }
                    } 
                    // Group-to-glyph substitution
                    else if (inputName.startsWith('$')) {
                         if (isItemDrawnOrNonEmptyGroup(inputName) && isNameDrawn(outputName)) {
                             const inputFeaName = toFeaName(inputName);
                             const outputGlyph = nameToGlyphName(outputName);
                             if (inputFeaName && outputGlyph) {
                                content += `  sub ${inputFeaName} by ${outputGlyph};\n`;
                             }
                         }
                    }
                    // Glyph-to-group is not standard OTF syntax for `single`, it would be a 'multiple' sub.
        
                    // Standard single substitution
                    else {
                        const inputGlyph = nameToGlyphName(inputName);
                        const outputGlyph = nameToGlyphName(outputName);
                        if (inputGlyph && outputGlyph && isNameDrawn(inputName) && isNameDrawn(outputName)) {
                            content += `  sub ${inputGlyph} by ${outputGlyph};\n`;
                        }
                    }
                }
            }
            return content;
        },
        liga: (ruleBlock: any) => {
            let content = '';
            for (const ligName in ruleBlock) {
                const componentNames = ruleBlock[ligName];
                if (Array.isArray(componentNames)) {
                    if (isNameDrawn(ligName) && componentNames.every(isItemDrawnOrNonEmptyGroup)) {
                        const componentGlyphs = componentNames.map(toFeaName).filter(Boolean);
                        const ligGlyph = nameToGlyphName(ligName);
                        if (ligGlyph && componentGlyphs.length > 0) {
                            content += `  sub ${componentGlyphs.join(' ')} by ${ligGlyph};\n`;
                        }
                    }
                }
            }
            return content;
        },
        multi: (ruleBlock: any) => {
            let content = '';
            for (const outputString in ruleBlock) {
                const inputNames = ruleBlock[outputString];
                if (!Array.isArray(inputNames) || inputNames.length === 0) continue;
                
                const inputName = inputNames[0];
                if (!isItemDrawnOrNonEmptyGroup(inputName)) continue;
                const inputFeaName = toFeaName(inputName);
                if (!inputFeaName) continue;
        
                const outputComponentNames = outputString.split(',').map(s => s.trim()).filter(Boolean);
                if (outputComponentNames.length === 0) continue;
        
                // Direct translation, no expansion
                const outputFeaNames = outputComponentNames.map(toFeaName).filter(Boolean);
        
                // Check if all components were resolved successfully
                if (outputFeaNames.length !== outputComponentNames.length) {
                    console.warn(`Could not resolve all output components for multi sub rule: '${outputString}'. Skipping rule.`);
                    continue;
                }
        
                if (outputFeaNames.length > 0) {
                    content += `  sub ${inputFeaName} by ${outputFeaNames.join(' ')};\n`;
                }
            }
            return content;
        },
        context: (ruleBlock: any) => {
            let content = '';
            for (const replacementName in ruleBlock) {
                const rule = ruleBlock[replacementName] as ContextualRuleValue;
                if (rule && Array.isArray(rule.replace) && rule.replace.length > 0) {
                    const targetNames = rule.replace;
                    const leftNames = rule.left || [];
                    const rightNames = rule.right || [];
                    
                    if (isNameDrawn(replacementName) && targetNames.every(isItemDrawnOrNonEmptyGroup) && leftNames.every(isItemDrawnOrNonEmptyGroup) && rightNames.every(isItemDrawnOrNonEmptyGroup)) {
                        const targetGlyphs = targetNames.map(toFeaName).filter(Boolean);
                        const replacementGlyph = nameToGlyphName(replacementName);
                        if (targetGlyphs.length > 0 && replacementGlyph) {
                            const leftGlyphs = leftNames.map(toFeaName).filter(Boolean);
                            const rightGlyphs = rightNames.map(toFeaName).filter(Boolean);
                            
                            const leftPart = leftGlyphs.join(' ');
                            const targetPart = targetGlyphs.map(g => `${g}'`).join(' ');
                            const rightPart = rightGlyphs.join(' ');
                            
                            const fullSequence = [leftPart, targetPart, rightPart].filter(Boolean).join(' ');
                            content += `  sub ${fullSequence} by ${replacementGlyph};\n`;
                        }
                    }
                }
            }
            return content;
        }
    };

    if (lookups) {
        for (const lookupName in lookups) {
            if (Object.prototype.hasOwnProperty.call(lookups, lookupName)) {
                const lookupBlock = lookups[lookupName];
                let namedLookupContent = '';

                if (lookupBlock.lookupflags) {
                    for (const flagName in lookupBlock.lookupflags) {
                        if (Object.prototype.hasOwnProperty.call(lookupBlock.lookupflags, flagName)) {
                            const flagValue = lookupBlock.lookupflags[flagName];
                            namedLookupContent += `  lookupflag ${flagName} ${flagValue};\n`;
                        }
                    }
                }

                for (const ruleType in lookupBlock) {
                    if (Object.prototype.hasOwnProperty.call(lookupBlock, ruleType) && ruleGenerators[ruleType as keyof typeof ruleGenerators]) {
                        namedLookupContent += ruleGenerators[ruleType as keyof typeof ruleGenerators](lookupBlock[ruleType]);
                    }
                }
                if (namedLookupContent) {
                    // Apply Layer 2 Sanitization here for lookup name
                    const safeLookupName = sanitizeIdentifier(lookupName);
                    allLookupDefinitions += `lookup ${safeLookupName} {\n${namedLookupContent}} ${safeLookupName};\n\n`;
                    generatedLookupNames.add(lookupName);
                }
            }
        }
    }

    for (const featureTag in scriptData) {
        if (!Object.prototype.hasOwnProperty.call(scriptData, featureTag)) continue;
        if (featureTag === 'dist') continue; // GPOS handled later
    
        const featureData = scriptData[featureTag];
        let featureLookups: string[] = [];
        const children = featureData.children || [];
    
        // 1. Detect if a feature has inline rules (i.e., rule content directly on the feature object).
        let anonymousRulesContent = '';
        for (const ruleType in featureData) {
            if (ruleGenerators[ruleType as keyof typeof ruleGenerators]) {
                anonymousRulesContent += ruleGenerators[ruleType as keyof typeof ruleGenerators](featureData[ruleType]);
            }
        }
        const hasInlineRules = anonymousRulesContent.trim() !== '';

        // Check if the feature references any named lookups
        const hasNamedLookups = (children.length > 0 && children.some((c: any) => c.type === 'lookup')) || 
                                (!children.length && featureData.lookups && Array.isArray(featureData.lookups) && featureData.lookups.length > 0);
    
        if (!hasNamedLookups && hasInlineRules) {
            // SIMPLE MODE: No named lookups, so we can output rules directly into the feature block.
            // This avoids creating a lookup wrapper, which is cleaner and prevents issues with mixed rule types inside a single lookup.
            let featureBlock = `feature ${featureTag} {\n`;
            
            // Add feature-level lookup flags
            if (featureData.lookupflags) {
                for (const flagName in featureData.lookupflags) {
                    if (Object.prototype.hasOwnProperty.call(featureData.lookupflags, flagName)) {
                        featureBlock += `  lookupflag ${flagName} ${featureData.lookupflags[flagName]};\n`;
                    }
                }
            }
            
            featureBlock += anonymousRulesContent;
            featureBlock += `} ${featureTag};\n\n`;
            feaContent += featureBlock;
            if (!allGsubFeatures.includes(featureTag)) allGsubFeatures.push(featureTag);

        } else {
            // MIXED or NAMED MODE: Use lookup wrappers/references to support ordering.
            // This preserves the original behavior for complex scenarios.
            
            // Handle lookups based on the 'children' array if it exists (new format).
            if (children.length > 0) {
                for (const child of children) {
                    if (child.type === 'lookup') {
                        featureLookups.push(child.name);
                    } else if (child.type === 'inline' && hasInlineRules) {
                        let inlineLookupContent = '';
                        // 2a. If lookupflags exist, move them inside the anonymous lookup.
                        if (featureData.lookupflags) {
                            for (const flagName in featureData.lookupflags) {
                                if (Object.prototype.hasOwnProperty.call(featureData.lookupflags, flagName)) {
                                    inlineLookupContent += `  lookupflag ${flagName} ${featureData.lookupflags[flagName]};\n`;
                                }
                            }
                        }
                        inlineLookupContent += anonymousRulesContent;
                        
                        const anonLookupName = `${featureTag}_inline_rules`;
                        if (!allLookupDefinitions.includes(`lookup ${anonLookupName}`)) {
                            allLookupDefinitions += `lookup ${anonLookupName} {\n${inlineLookupContent}} ${anonLookupName};\n\n`;
                            generatedLookupNames.add(anonLookupName);
                        }
                        featureLookups.push(anonLookupName);
                    }
                }
            } else { // Fallback for old data structure without 'children'.
                if (featureData.lookups && Array.isArray(featureData.lookups)) {
                    featureLookups.push(...featureData.lookups);
                }
                if (hasInlineRules) {
                    let inlineLookupContent = '';
                    if (featureData.lookupflags) {
                        for (const flagName in featureData.lookupflags) {
                            inlineLookupContent += `  lookupflag ${flagName} ${featureData.lookupflags[flagName]};\n`;
                        }
                    }
                    inlineLookupContent += anonymousRulesContent;
                    const anonLookupName = `${featureTag}_inline_rules`;
                    if (!allLookupDefinitions.includes(`lookup ${anonLookupName}`)) {
                        allLookupDefinitions += `lookup ${anonLookupName} {\n${inlineLookupContent}} ${anonLookupName};\n\n`;
                        generatedLookupNames.add(anonLookupName);
                    }
                    featureLookups.push(anonLookupName);
                }
            }
            
            const validLookups = featureLookups.filter(name => generatedLookupNames.has(name));
        
            if (validLookups.length > 0) {
                let featureBlock = `feature ${featureTag} {\n`;
                // 3. Only add lookupflags at the feature level if there are NO inline rules (since those are wrapped with flags).
                // If there ARE inline rules, the flags moved into the wrapper.
                if (featureData.lookupflags && !hasInlineRules) {
                    for (const flagName in featureData.lookupflags) {
                        if (Object.prototype.hasOwnProperty.call(featureData.lookupflags, flagName)) {
                            featureBlock += `  lookupflag ${flagName} ${featureData.lookupflags[flagName]};\n`;
                        }
                    }
                }
                validLookups.forEach(name => {
                    // Apply Layer 2 Sanitization here for lookup reference
                    featureBlock += `  lookup ${sanitizeIdentifier(name)};\n`;
                });
                featureBlock += `} ${featureTag};\n\n`;
                feaContent += featureBlock;
                if (!allGsubFeatures.includes(featureTag)) allGsubFeatures.push(featureTag);
            }
        }
    }
    
    // Add all lookup definitions before the first feature that uses them.
    feaContent = feaContent.replace('## GDEF Table', `${allLookupDefinitions}## GDEF Table`);
    
    // --- GPOS Features ---
    const gposFeatures = new Map<string, string[]>();
    const FONT_HEIGHT = metrics.ascender - metrics.descender;
    const scale = FONT_HEIGHT / DRAWING_CANVAS_SIZE;

    const pairToGposTag = new Map<string, string>();

    // Priority 1: Populate from positioning.json rules.
    if (positioningRules) {
        positioningRules.forEach(rule => {
            if (rule.gpos) {
                const bases = expandMembers(rule.base, groups, characterSets);
                const marks = expandMembers(rule.mark || [], groups, characterSets);
                bases.forEach(baseName => {
                    marks.forEach(markName => {
                        pairToGposTag.set(`${baseName}-${markName}`, rule.gpos!);
                    });
                });
            }
        });
    }

    // Priority 2: Populate with fallbacks from characters.json.
    allCharsByUnicode.forEach(char => {
        if (char.position && char.gpos) {
            const [baseName, markName] = char.position;
            const pairKey = `${baseName}-${markName}`;
            if (!pairToGposTag.has(pairKey)) { // Only add if not already defined (priority)
                pairToGposTag.set(pairKey, char.gpos);
            }
        }
    });

    if (pairToGposTag.size > 0) {
        const markClasses = new Map<string, string>(); // mark glyph name -> class name
        
        markPositioningMap.forEach((offset, key) => {
            const [baseUnicode, markUnicode] = key.split('-').map(Number);
            const baseChar = allCharsByUnicode.get(baseUnicode);
            const markChar = allCharsByUnicode.get(markUnicode);

            if (!baseChar || !markChar || !isGlyphDrawn(baseChar) || !isGlyphDrawn(markChar)) return;
            
            const gposTag = pairToGposTag.get(`${baseChar.name}-${markChar.name}`);
            if (!gposTag) return; 

            const baseGlyphName = getGlyphName(baseChar);
            const markGlyphName = getGlyphName(markChar);
            if (!baseGlyphName || !markGlyphName) return;

            const baseBbox = glyphBBoxes.get(baseUnicode);
            const markBbox = glyphBBoxes.get(markUnicode);
            if (!baseBbox || !markBbox) return;

            let markClassName = markClasses.get(markGlyphName);
            if (!markClassName) {
                markClassName = `@mark_${markGlyphName}`;
                markClasses.set(markGlyphName, markClassName);
            }

            if (!gposFeatures.has(gposTag)) gposFeatures.set(gposTag, []);
            
            const LSB_f = baseChar.lsb ?? metrics.defaultLSB;
            
            const canvas_distance_x = (markBbox.x + offset.x) - baseBbox.x;
            const font_distance_x = canvas_distance_x * scale;
            const anchorX = Math.round(LSB_f + font_distance_x);

            const anchorY = Math.round(-offset.y * scale);
            
            if (baseChar.glyphClass === 'mark') {
                if (!markClasses.has(baseGlyphName)) {
                    markClasses.set(baseGlyphName, `@mark_${baseGlyphName}`);
                }
                gposFeatures.get(gposTag)!.push(`  pos mark ${baseGlyphName} <anchor ${anchorX} ${anchorY}> mark ${markClassName};\n`);
            } else {
                gposFeatures.get(gposTag)!.push(`  pos base ${baseGlyphName} <anchor ${anchorX} ${anchorY}> mark ${markClassName};\n`);
            }
        });

        if(markClasses.size > 0) {
            feaContent += '## Mark Classes\n';
            markClasses.forEach((className, glyphName) => {
                feaContent += `markClass ${glyphName} <anchor 0 0> ${className};\n`;
            });
            feaContent += '\n';
        }

        gposFeatures.forEach((rules, tag) => {
            feaContent += `feature ${tag} {\n${rules.join('')}} ${tag};\n\n`;
            if (!allGposFeatures.includes(tag)) allGposFeatures.push(tag);
        });
    }

    let distContent = '';
    kerningMap.forEach((value, key) => {
        const [leftUnicode, rightUnicode] = key.split('-').map(Number);
        const leftChar = allCharsByUnicode.get(leftUnicode);
        const rightChar = allCharsByUnicode.get(rightUnicode);

        if (leftChar && rightChar && isGlyphDrawn(leftChar) && isGlyphDrawn(rightChar) && value !== 0) {
            const leftGlyph = getGlyphName(leftChar);
            const rightGlyph = getGlyphName(rightChar);
            if (leftGlyph && rightGlyph) {
                distContent += `  pos ${leftGlyph} ${rightGlyph} ${value};\n`;
            }
        }
    });
    
    if (scriptData.dist) {
        if (scriptData.dist.simple) {
            for (const charOrGroupName in scriptData.dist.simple) {
                if (!isItemDrawnOrNonEmptyGroup(charOrGroupName)) continue;
                const feaName = toFeaName(charOrGroupName);
                if (!feaName) continue;
                const value = scriptData.dist.simple[charOrGroupName];
                distContent += `  pos ${feaName} <0 0 ${value} 0>;\n`;
            }
        }

        if (scriptData.dist.contextual && Array.isArray(scriptData.dist.contextual)) {
            scriptData.dist.contextual.forEach((rule: any) => {
                const charName = rule.target;
                if (!charName) return;
                
                if (typeof rule === 'object' && rule !== null && rule.space) {
                    const leftNames = rule.left || [];
                    const rightNames = rule.right || [];
                    
                    if (isItemDrawnOrNonEmptyGroup(charName) && leftNames.every(isItemDrawnOrNonEmptyGroup) && rightNames.every(isItemDrawnOrNonEmptyGroup)) {
                        const glyphName = toFeaName(charName);
                        if (!glyphName) return;

                        const leftGlyphs = leftNames.map(toFeaName).filter(Boolean);
                        const rightGlyphs = rightNames.map(toFeaName).filter(Boolean);
                        
                        const leftContext = leftGlyphs.length > 0 ? `${leftGlyphs.join(' ')} ` : '';
                        const rightContext = rightGlyphs.length > 0 ? ` ${rightGlyphs.join(' ')}` : '';
                        
                        distContent += `  pos ${leftContext}${glyphName}'${rightContext} <0 0 ${rule.space} 0>;\n`;
                    }
                }
            });
        }
    }
    
    if (distContent.trim() === '') {
        // Add a dummy rule to ensure the feature block is valid if no other rules are present
        distContent = '  # No kerning or distance rules defined.\n';
    }

    feaContent += `feature dist {\n${distContent}} dist;\n\n`;
    if (!allGposFeatures.includes('dist')) {
        allGposFeatures.push('dist');
    }

    return feaContent;
};

export const exportFeaFile = (
    fontRules: any,
    kerningMap: KerningMap,
    markPositioningMap: MarkPositioningMap,
    allCharsByUnicode: Map<number, Character>,
    fontName: string,
    positioningRules: PositioningRules[] | null,
    glyphDataMap: Map<number, GlyphData>,
    metrics: FontMetrics,
    strokeThickness: number = 15,
    characterSets: CharacterSet[]
) => {
    const glyphBBoxes = new Map<number, BoundingBox | null>();
    glyphDataMap.forEach((glyphData, unicode) => {
        glyphBBoxes.set(unicode, getAccurateGlyphBBox(glyphData.paths, strokeThickness));
    });

    const feaContent = generateFea(
        fontRules,
        kerningMap,
        markPositioningMap,
        allCharsByUnicode,
        fontName,
        positioningRules,
        glyphDataMap,
        metrics,
        glyphBBoxes,
        characterSets
    );

    const blob = new Blob([feaContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Apply Layer 2 Sanitization here for filename as a courtesy
    a.download = `${sanitizeIdentifier(fontName)}.fea`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

export const exportJsonRules = (rules: any, fontName: string) => {
    const jsonString = JSON.stringify(rules, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Apply Layer 2 Sanitization here for filename
    a.download = `${sanitizeIdentifier(fontName)}_rules.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};
