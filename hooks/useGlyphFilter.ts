import { useMemo } from 'react';
import { Character, GlyphData, MarkPositioningMap, KerningMap } from '../types';
import { useLayout } from '../contexts/LayoutContext';
import { isGlyphDrawn } from '../utils/glyphUtils';
import { filterAndSortCharacters } from '../utils/searchUtils';

interface UseGlyphFilterProps {
    characters: Character[];
    glyphDataMap: Map<number, GlyphData>;
    markPositioningMap: MarkPositioningMap;
    kerningMap: KerningMap;
    allCharsByName: Map<string, Character>;
    showHidden?: boolean;
}

export const useGlyphFilter = ({
    characters,
    glyphDataMap,
    markPositioningMap,
    kerningMap,
    allCharsByName,
    showHidden = false
}: UseGlyphFilterProps) => {
    const { filterMode, searchQuery } = useLayout();
    const isSearching = searchQuery.trim().length > 0;
    const isFiltered = filterMode !== 'none' || isSearching;

    const filteredList = useMemo(() => {
        let candidates = characters.filter(char => {
            // Standard ZWJ/ZWNJ exclusion
            if (char.unicode === 8205 || char.unicode === 8204) return false;
            
            // Auto-Generated Logic: Show all virtual glyphs (position/kern pairs) regardless of status
            if (filterMode === 'autoGenerated') {
                const isVirtual = !!char.position || !!char.kern;
                return isVirtual && (!char.hidden || showHidden);
            }

            // Drawn (Sources) Logic: Show non-virtual glyphs that have content
            if (filterMode === 'drawn') {
                 const isVirtual = !!char.position || !!char.kern;
                 const glyph = glyphDataMap.get(char.unicode!);
                 const hasContent = isGlyphDrawn(glyph);
                 // Only return glyphs that are drawn AND NOT virtual (position/kern pairs)
                 return hasContent && !isVirtual && (!char.hidden || showHidden);
            }

            let isComplete = false;
            if (char.position) {
                 const [base, mark] = char.position;
                 const baseC = allCharsByName.get(base);
                 const markC = allCharsByName.get(mark);
                 if (baseC?.unicode !== undefined && markC?.unicode !== undefined) {
                     const key = `${baseC.unicode}-${markC.unicode}`;
                     isComplete = markPositioningMap.has(key);
                 }
            } else if (char.kern) {
                 const [left, right] = char.kern;
                 const leftC = allCharsByName.get(left);
                 const rightC = allCharsByName.get(right);
                 if (leftC?.unicode !== undefined && rightC?.unicode !== undefined) {
                     const key = `${leftC.unicode}-${rightC.unicode}`;
                     isComplete = kerningMap.has(key);
                 }
            } else if (char.unicode !== undefined) {
                 isComplete = isGlyphDrawn(glyphDataMap.get(char.unicode));
            }

            const matchesStatus = filterMode === 'all' || filterMode === 'none' || (filterMode === 'completed' && isComplete) || (filterMode === 'incomplete' && !isComplete);
            
            if (!matchesStatus) return false;
            return (!char.hidden || showHidden);
        });
        
        return isSearching ? filterAndSortCharacters(candidates, searchQuery) : candidates.sort((a, b) => (a.unicode || 0) - (b.unicode || 0));
    }, [characters, glyphDataMap, filterMode, showHidden, searchQuery, isSearching, markPositioningMap, kerningMap, allCharsByName]);

    return { filteredList, isFiltered };
};
