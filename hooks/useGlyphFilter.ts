
import { useMemo } from 'react';
import { Character, GlyphData, MarkPositioningMap, KerningMap } from '../types';
import { useLayout } from '../contexts/LayoutContext';
import { isGlyphDrawn } from '../utils/glyphUtils';
import { filterAndSortCharacters } from '../utils/searchUtils';

interface UseGlyphFilterProps {
    characters: Character[];
    glyphDataMap: Map<number, GlyphData>;
    markPositioningMap: MarkPositioningMap;
    kerningMap: KerningMap;
    allCharsByName: Map<string, Character>;
    showHidden?: boolean;
}

export const useGlyphFilter = ({
    characters,
    glyphDataMap,
    markPositioningMap,
    kerningMap,
    allCharsByName,
    showHidden = false
}: UseGlyphFilterProps) => {
    const { filterMode, searchQuery } = useLayout();
    const isSearching = searchQuery.trim().length > 0;
    const isFiltered = filterMode !== 'none' || isSearching;

    const filteredList = useMemo(() => {
        let candidates = characters.filter(char => {
            // Standard ZWJ/ZWNJ exclusion
            if (char.unicode === 8205 || char.unicode === 8204) return false;
            
            // Definition: "Auto-Generated" means it's constructed via logic (Positioning, Kerning) or Link reference.
            const isAutoDerived = !!char.position || !!char.kern || !!char.link;

            // Auto-Generated Logic: Show all derived glyphs regardless of status
            if (filterMode === 'autoGenerated') {
                return isAutoDerived && (!char.hidden || showHidden);
            }

            // To Be Reviewed Logic: Auto-derived AND Incomplete AND Components Drawn
            if (filterMode === 'toBeReviewed') {
                if (char.position) {
                    const [base, mark] = char.position;
                    const baseC = allCharsByName.get(base);
                    const markC = allCharsByName.get(mark);
                    if (baseC?.unicode !== undefined && markC?.unicode !== undefined) {
                         const key = `${baseC.unicode}-${markC.unicode}`;
                         // Must NOT be saved
                         if (markPositioningMap.has(key)) return false;
                         
                         // Components MUST be drawn
                         const baseDrawn = isGlyphDrawn(glyphDataMap.get(baseC.unicode));
                         const markDrawn = isGlyphDrawn(glyphDataMap.get(markC.unicode));
                         return baseDrawn && markDrawn && (!char.hidden || showHidden);
                    }
                } else if (char.kern) {
                    const [left, right] = char.kern;
                    const leftC = allCharsByName.get(left);
                    const rightC = allCharsByName.get(right);
                    if (leftC?.unicode !== undefined && rightC?.unicode !== undefined) {
                         const key = `${leftC.unicode}-${rightC.unicode}`;
                         // Must NOT be saved
                         if (kerningMap.has(key)) return false;
                         
                         // Components MUST be drawn
                         const leftDrawn = isGlyphDrawn(glyphDataMap.get(leftC.unicode));
                         const rightDrawn = isGlyphDrawn(glyphDataMap.get(rightC.unicode));
                         return leftDrawn && rightDrawn && (!char.hidden || showHidden);
                    }
                }
                return false;
            }

            // Drawn (Sources) Logic: Show manual source glyphs (Base, Mark, etc.)
            // We do NOT check hasContent here, so empty source glyphs are visible for the user to find and draw.
            if (filterMode === 'drawn') {
                 return !isAutoDerived && (!char.hidden || showHidden);
            }

            // Glyph Class Filters
            if (filterMode === 'base') {
                // If glyphClass is undefined, we assume it's a base character by default
                return (char.glyphClass === 'base' || !char.glyphClass) && (!char.hidden || showHidden);
            }
            if (filterMode === 'ligature') {
                return char.glyphClass === 'ligature' && (!char.hidden || showHidden);
            }
            if (filterMode === 'mark') {
                return char.glyphClass === 'mark' && (!char.hidden || showHidden);
            }

            let isComplete = false;
            if (char.position) {
                 const [base, mark] = char.position;
                 const baseC = allCharsByName.get(base);
                 const markC = allCharsByName.get(mark);
                 if (baseC?.unicode !== undefined && markC?.unicode !== undefined) {
                     const key = `${baseC.unicode}-${markC.unicode}`;
                     isComplete = markPositioningMap.has(key);
                 }
            } else if (char.kern) {
                 const [left, right] = char.kern;
                 const leftC = allCharsByName.get(left);
                 const rightC = allCharsByName.get(right);
                 if (leftC?.unicode !== undefined && rightC?.unicode !== undefined) {
                     const key = `${leftC.unicode}-${rightC.unicode}`;
                     isComplete = kerningMap.has(key);
                 }
            } else if (char.unicode !== undefined) {
                 isComplete = isGlyphDrawn(glyphDataMap.get(char.unicode));
            }

            const matchesStatus = filterMode === 'all' || filterMode === 'none' || (filterMode === 'completed' && isComplete) || (filterMode === 'incomplete' && !isComplete);
            
            if (!matchesStatus) return false;
            return (!char.hidden || showHidden);
        });
        
        return isSearching ? filterAndSortCharacters(candidates, searchQuery) : candidates.sort((a, b) => (a.unicode || 0) - (b.unicode || 0));
    }, [characters, glyphDataMap, filterMode, showHidden, searchQuery, isSearching, markPositioningMap, kerningMap, allCharsByName]);

    return { filteredList, isFiltered };
};
